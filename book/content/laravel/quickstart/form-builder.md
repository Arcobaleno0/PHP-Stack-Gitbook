# Form Builder

At this point, you should have a working form that will allow you to add posts to the database. Writing forms in HTML is pretty easy, but Laravel provides some tools to make it even easier. There are certainly pros and cons to having your framework generate HTML. We will discuss some of the reasons that it may be worthwhile in this lesson and then you will get to try it out for yourself.

## Creating a Form

Currently, you probably have a form that looks something like this:

~~~html
<form method="POST" action="{{ action('PostsController@store') }}">
</form>

// which renders like this...

<form method="POST" action="http://blog.dev/posts">
</form>
~~~

Here is what the same form would look like if written with the form builder:

~~~html
{{ Form::open(array('action' => 'PostsController@store')) }}
{{ Form::close() }}

// which renders like this...

<form method="POST" action="http://blog.dev/posts" accept-charset="UTF-8">
<input name="_token" type="hidden" value="Y7Eb2IsFvNv4jY2nx6BzrjhSlWlWuLbpfJEuLpOd">
</form>
~~~

Notice how the form generated by the form builder has a couple things that our basic form did not. The thing to notice is the auto insertion of a hidden input named `_token`. Laravel can use this to prevent **C**ross **S**ite **R**equest **F**orgery (CSRF) attacks. These can occur when another webpage or program tries to submit a form for processing on your site. We will talk more about this shortly.

Another neat feature of the form builder is support for emulating HTTP methods that the browser will not natively perform. For example, remember how we saw the `PUT` and `DELETE` verbs when we discussed resource controllers? Well, check this out:

~~~html
{{ Form::open(array('action' => array('PostsController@update', $post->id), 'method' => 'PUT')) }}
{{ Form::close() }}

// which renders like this...

<form method="POST" action="http://blog.dev/posts/%7Bposts%7D" accept-charset="UTF-8">
<input name="_method" type="hidden" value="PUT">
<input name="_token" type="hidden" value="Y7Eb2IsFvNv4jY2nx6BzrjhSlWlWuLbpfJEuLpOd">
</form>
~~~

This is the form that would be used to update a post. See how the form `method` can be added to the form parameters? When you specify a method of `PUT` or `DELETE` a special hidden form input named `_method` gets added so that Laravel knows how it should process the request. You can manually add the `_method`, but it is nice to have the form builder do it for us.

One other nice feature about the form builder is the ability to pass a model instance to the form. When the form builder is used in this way, form inputs will automatically have the appropriate values based on the model that is specified. Here is what the update form would look like if we passed an existing post instance:

~~~php
{{ Form::model($post, array('action' => array('PostsController@update', $post->id), 'method' => 'PUT')) }}
{{ Form::close() }}
~~~

That one simple change saves the work of specifying initial values for the form inputs.

## Adding Inputs

Now that we have discussed how to open and close a form, we can briefly cover form inputs.

~~~html
{{ Form::label('title', 'Title') }}
{{ Form::text('title') }}

// which renders like this...

<label for="title">Title</label>
<input name="title" type="text" id="title">
~~~

As you can see, we were able to generate a form label and input quite simply. The greatest part about this is that if we passed an existing post instance to the form open method then the title will automatically have its value set.

There are a ton of options for building form inputs. Please see the links in the additional info section below for details.

## CSRF Protection and Controller Filters

We started to discuss **C**ross **S**ite **R**equest **F**orgery (CSRF) protection earlier in this lesson. It should be noted that whether you use the form builder or not, you can take advantage of this feature.

To add the CSRF `_token` input to your form without the form builder, use the `Form::token()` method as follows:

~~~html
<form method="POST" action="{{ action('PostsController@store') }}">
{{ Form::token() }}
</form>
~~~

Just having the `_token` input in your form is not quite enough. You need to tell Laravel that you want to enable CSRF protection. The easiest way to do this is to instruct Laravel to require a CSRF token for all `POST`, `PUT`, or `DELETE` requests. Add the following method to your `BaseController` to add CSRF protection:

~~~php
public function __construct()
{
    // require csrf token for all post, delete, and put actions
    $this->beforeFilter('csrf', array('on' => array('post', 'delete', 'put')));
}
~~~

The code above is a PHP class constructor magic method. By placing this in the `BaseController`, any controller that extends from it will automatically get this functionality. In this case, the functionality we added is a special `beforeFilter`. This is another nice feature that lets us add special code that should be called before processing controller actions. Here were are applying the built-in `csrf` filter to all `POST`, `PUT`, and `DELETE` actions as we discussed. Once this line is added, you will receive errors if you submit a form that you have not added the `_token` to.

We will soon be using another filter to help use with authentication. Read more about filters and all that you can do with them here: https://laravel.com/docs/4.2/controllers#controller-filters

## Additional Information

For additional information on the form builder, see the links below:

- https://laravel.com/docs/4.2/html
- http://daylerees.com/codebright/forms

## Exercises

Please follow the instructions below, and as always commit your work to git and push to GitHub.

1. Update your form for creating a new post so that it uses the form builder.
1. Create a view for handling post updates and complete the `edit` and `update` actions on the `PostController`.. Bonus: Try to re-use the post creation form for updating posts.
1. Enable CSRF for all `POST`, `PUT`, and `DELETE` requests.

